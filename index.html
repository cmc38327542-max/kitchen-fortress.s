<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ì£¼ë°© í¬íŠ¸ë¦¬ìŠ¤: ë§ˆì™•ì¡±ë°œ vs ìƒì•„êµ¬</title>
  <style>
    :root{--bg:#070b14;--card:#111827;--text:#e5e7eb;--muted:#94a3b8;}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",Arial,sans-serif;background:linear-gradient(180deg,#050812,#0b1220);color:var(--text);}
    .wrap{max-width:980px;margin:0 auto;padding:14px;}
    h1{margin:8px 0 4px;font-size:22px}
    .sub{margin:0 0 12px;color:var(--muted);font-size:13px;line-height:1.4}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .card{background:rgba(17,24,39,.72);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,.28)}
    canvas{width:100%;height:auto;display:block;border-radius:16px;border:1px solid rgba(255,255,255,.08);
      background:
        radial-gradient(900px 400px at 50% 100%, rgba(34,197,94,.14), transparent 60%),
        linear-gradient(180deg, rgba(2,6,23,.08), rgba(2,6,23,.78));
    }
    .hud{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .pill{display:flex;gap:10px;align-items:center;padding:8px 10px;border-radius:999px;background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.08);font-size:13px;flex-wrap:wrap}
    button{cursor:pointer;border:1px solid rgba(255,255,255,.12);background:rgba(17,24,39,.7);color:var(--text);padding:8px 10px;border-radius:10px;font-weight:800}
    button:hover{filter:brightness(1.15)}
    button.primary{background:rgba(34,197,94,.28);border-color:rgba(34,197,94,.55)}
    .hint{color:var(--muted);font-size:13px;line-height:1.45}
    .small{color:var(--muted);font-size:12px;margin-top:10px}
    .tag{font-size:12px;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);color:var(--muted);display:inline-block}
  </style>
</head>
<body>
<div class="wrap">
  <h1>ì£¼ë°© í¬íŠ¸ë¦¬ìŠ¤ ğŸ¥˜ğŸ’¥  ë§ˆì™•ì¡±ë°œ vs ìƒì•„êµ¬</h1>
  <p class="sub">
    <b>í„´ì œ</b>ë¡œ ì„œë¡œ ë§ì¶°ì„œ HPë¥¼ 0ìœ¼ë¡œ ë§Œë“¤ë©´ ìŠ¹ë¦¬.<br/>
    ë‚´ í„´ì¼ ë•Œë§Œ <b>ë“œë˜ê·¸â†’ë†“ê¸°</b>ë¡œ ë°œì‚¬. í„´ë§ˆë‹¤ <b>ë°”ëŒ(WIND)</b>ì´ ë°”ë€œ.
  </p>

  <div class="row">
    <div class="card" style="flex:1 1 640px;">
      <div class="hud">
        <div class="pill">
          <span>ğŸŒ€ WIND: <b id="wind">0</b></span>
          <span>ğŸ¯ í„´: <b id="turn">ì„œì¸ì¬</b></span>
          <span>â±ï¸ í„´ì‹œê°„: <b id="timer">--</b></span>
        </div>
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <button id="startBtn" class="primary">ê²Œì„ ì‹œì‘</button>
          <button id="resetBtn">ë¦¬ì…‹</button>
        </div>
      </div>

      <div style="margin-top:10px;">
        <canvas id="c" width="900" height="520"></canvas>
      </div>

      <div class="small" id="msg">ğŸ’¬ ì¤€ë¹„ ì™„ë£Œ. â€œê²Œì„ ì‹œì‘â€ì„ ëˆŒëŸ¬!</div>
    </div>

    <div class="card" style="flex:1 1 300px;">
      <div class="tag">ìºë¦­í„°</div>
      <div class="hint" style="margin-top:10px;">
        <b>ì„œì¸ì¬(190)</b> : ë¬´í‘œì •/ê°ì •ì—†ìŒ, ëŠë¦¿í•œ ê³¨ë ˜ ëŠë‚Œ<br/>
        ëŒ€ì‚¬: <b>â€œì¸ìƒë§í•´ë¼!â€</b><br/>
        ë¬´ê¸°: <b>ìƒì•„êµ¬ ë¯¸ì‚¬ì¼</b> (ê°€ë²¼ì›€, íƒ„ë„ ë†’ìŒ)<br/><br/>
        <b>ì•ˆì¡±ë°œ</b> : ì‘ê³  ëš±ëš±, ëŒ€ë¨¸ë¦¬ + ì•ˆê²½ ëŠë‚Œ, ë§ˆì™•ì¡±ë°œ<br/>
        ëŒ€ì‚¬: <b>â€œê·¸ë§Œì¢€ê´´ë¡­í˜€!â€</b><br/>
        ë¬´ê¸°: <b>ë§ˆì™•ì¡±ë°œ ì•ë‹¤ë¦¬ ë¯¸ì‚¬ì¼</b> (ë¬´ê±°ì›€, íƒ„ë„ ë‚®ìŒ)
      </div>

      <div class="card" style="margin-top:12px;background:rgba(17,24,39,.55);">
        <div class="hint">
          <b>ì¡°ì‘</b><br/>
          ë‚´ í„´ì¼ ë•Œ ìºë¦­í„° â€œì† ê·¼ì²˜â€ íƒ„ì„ í´ë¦­(ì¡ê¸°) â†’ ë“œë˜ê·¸ â†’ ë†“ê¸°<br/>
          ë“œë˜ê·¸ ê¸¸ì´ = í˜ / ë°©í–¥ = ë°œì‚¬ ë°©í–¥
        </div>
      </div>

      <div class="card" style="margin-top:12px;background:rgba(17,24,39,.55);">
        <div class="hint">
          <b>íŒ</b><br/>
          ë°”ëŒì´ ê°•í•˜ë©´ íƒ„ì´ ì˜†ìœ¼ë¡œ ë°€ë¦°ë‹¤.<br/>
          ì•½í•˜ê²Œ ë˜ì§€ë©´ ë°”ë¡œ ì•ì—ì„œ ë–¨ì–´ì§€ê³ , ë„ˆë¬´ ì„¸ë©´ ì§€ë‚˜ì¹œë‹¤.
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const windEl = document.getElementById('wind');
  const turnEl = document.getElementById('turn');
  const timerEl = document.getElementById('timer');
  const msgEl = document.getElementById('msg');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');

  // ===== Physics =====
  const G = 1200;
  const BASE_WIND = 140; // í„´ë§ˆë‹¤ -140~+140 px/s^2 ê°€ì†(ëŒ€ì¶© ëŠë‚Œ)
  const REST = 0.55;
  const FRICTION = 0.985;

  // ===== Field =====
  const GROUND_Y = 450;
  const LEFT = 30, RIGHT = canvas.width - 30;

  // ===== Turn =====
  const TURN_LIMIT = 20; // seconds
  let running = false;
  let last = performance.now();
  let turn = 0;               // 0: ì„œì¸ì¬, 1: ì•ˆì¡±ë°œ
  let wind = 0;
  let turnTimeLeft = TURN_LIMIT;

  // "ì…ë ¥ ì ê¸ˆ"ê³¼ "í„´ ì „í™˜ ì ê¸ˆ" ë¶„ë¦¬ (ì´ê²Œ í•µì‹¬)
  let shotInAir = false;         // íƒ„ì´ ë‚ ì•„ê°€ëŠ” ë™ì•ˆë§Œ ì…ë ¥ ê¸ˆì§€
  let turnTransitioning = false; // í„´ ë„˜ì–´ê°€ëŠ” ì¤‘ ì¤‘ë³µ ë°©ì§€

  // ===== Characters =====
  const players = [
    {
      id: 'seo',
      name: 'ì„œì¸ì¬',
      x: 160,
      y: GROUND_Y,
      hp: 100,
      body: { w: 48, h: 128 },     // ì¥ì‹  ëŠë‚Œ
      head: { r: 18 },
      // ì•„êµ¬: ê°€ë³ê³  ë†’ê²Œ
      projectile: { kind:'agu', r: 14, air: 0.992, bounce: 0.72, powerMul: 1.00, arcMul: 1.10, dmg: 26 },
      taunt: 'ì¸ìƒë§í•´ë¼!'
    },
    {
      id: 'jokbal',
      name: 'ì•ˆì¡±ë°œ',
      x: 740,
      y: GROUND_Y,
      hp: 100,
      body: { w: 84, h: 92 },      // ì§§ê³  ëš±
      head: { r: 22 },
      // ì¡±ë°œ: ë¬´ê²ê³  ë‚®ê²Œ
      projectile: { kind:'jokbal', r: 18, air: 0.995, bounce: 0.45, powerMul: 1.12, arcMul: 0.92, dmg: 30 },
      taunt: 'ê·¸ë§Œì¢€ê´´ë¡­í˜€!'
    }
  ];

  // ===== Shots =====
  let shots = [];

  class Shot {
    constructor(ownerIndex, x, y, vx, vy) {
      const p = players[ownerIndex];
      const pr = p.projectile;
      this.owner = ownerIndex;
      this.kind = pr.kind;
      this.r = pr.r;
      this.air = pr.air;
      this.bounce = pr.bounce;
      this.dmg = pr.dmg;
      this.x = x; this.y = y;
      this.vx = vx; this.vy = vy;
      this.dead = false;
      this.hit = false;
      this.createdAt = performance.now();
      this.lastY = y;
    }

    update(dt) {
      this.lastY = this.y;

      // air
      this.vx *= this.air;
      this.vy *= this.air;

      // gravity + wind
      this.vy += G * dt;
      this.vx += wind * dt;

      // move
      this.x += this.vx * dt;
      this.y += this.vy * dt;

      // walls
      if (this.x - this.r < LEFT) { this.x = LEFT + this.r; this.vx = -this.vx * REST; }
      if (this.x + this.r > RIGHT){ this.x = RIGHT - this.r; this.vx = -this.vx * REST; }

      // ground bounce
      if (this.y + this.r > GROUND_Y) {
        this.y = GROUND_Y - this.r;
        this.vy = -this.vy * this.bounce;
        this.vx *= FRICTION;
        if (Math.abs(this.vy) < 45) this.vy = 0;
      }

      // hit check (enemy only)
      const enemy = players[1 - this.owner];
      if (!this.hit && circleHitsPlayer(this, enemy)) {
        this.hit = true;
        applyDamage(1 - this.owner, this.dmg, this.vx);
        this.dead = true;

        // ë§ìœ¼ë©´ ì¦‰ì‹œ í„´ ì¢…ë£Œ
        endTurn(`${players[this.owner].name} ì ì¤‘! -${this.dmg} HP`);
        return;
      }

      // lifetime
      if (performance.now() - this.createdAt > 5500) {
        this.dead = true;
        // ì‹œê°„ ì§€ë‚˜ë„ ì•ˆ ë§ìœ¼ë©´ í„´ ì¢…ë£Œ
        endTurn(`${players[this.owner].name} ê³µê²© ë¹—ë‚˜ê°â€¦`);
      }
    }

    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);

      if (this.kind === 'jokbal') {
        // ì¡±ë°œ
        ctx.beginPath();
        ctx.arc(0, 0, this.r, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(236,179,95,0.95)";
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-6, -2);
        ctx.lineTo(10, 7);
        ctx.stroke();
      } else {
        // ì•„êµ¬
        ctx.beginPath();
        ctx.arc(0, 0, this.r, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(147,197,253,0.95)";
        ctx.fill();
        ctx.fillStyle = "rgba(2,6,23,0.75)";
        ctx.beginPath();
        ctx.arc(4, -3, 2.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(2,6,23,0.35)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-this.r, 0);
        ctx.lineTo(-this.r - 8, -6);
        ctx.moveTo(-this.r, 0);
        ctx.lineTo(-this.r - 8, 6);
        ctx.stroke();
      }

      ctx.restore();
    }
  }

  // ===== Collision: shot vs player (ellipse approx) =====
  function circleHitsPlayer(shot, pl) {
    const cx = pl.x;
    const cy = pl.y - pl.body.h * 0.55;
    const rx = pl.body.w * 0.60;
    const ry = pl.body.h * 0.58;

    const dx = shot.x - cx;
    const dy = shot.y - cy;
    const v = (dx*dx)/(rx*rx) + (dy*dy)/(ry*ry);

    // ì› ë°˜ì§€ë¦„ì„ íƒ€ì› íŒì •ì— ì•½ê°„ ë°˜ì˜(ë„‰ë„‰í•˜ê²Œ)
    return v <= 1.0 + (shot.r / 80);
  }

  function applyDamage(playerIndex, dmg, hitVx) {
    const pl = players[playerIndex];
    pl.hp = Math.max(0, pl.hp - dmg);

    // knockback (ì‚´ì§ë§Œ)
    const knock = Math.max(-70, Math.min(70, hitVx * 0.012));
    pl.x += knock;
    pl.x = Math.max(90, Math.min(canvas.width - 90, pl.x));

    if (pl.hp <= 0) {
      running = false;
      shotInAir = false;
      turnTransitioning = false;
      toast(`ğŸ† ${players[1-playerIndex].name} ìŠ¹ë¦¬! (â€œ${players[1-playerIndex].taunt}â€)`);
    }
  }

  // ===== Turn logic =====
  function setWind() {
    wind = (Math.random() * 2 - 1) * BASE_WIND;
    windEl.textContent = wind.toFixed(0);
  }
  function setTurnUI() { turnEl.textContent = players[turn].name; }

  function beginTurn() {
    if (!running) return;
    setWind();
    setTurnUI();
    turnTimeLeft = TURN_LIMIT;
    shotInAir = false; // ìƒˆ í„´ ì‹œì‘í•  ë•Œ ì…ë ¥ ê°€ëŠ¥
    toast(`ğŸ¯ ${players[turn].name} í„´! â€œ${players[turn].taunt}â€`);
  }

  function endTurn(reason) {
    if (!running) return;
    if (turnTransitioning) return;

    turnTransitioning = true;
    shotInAir = false;

    setTimeout(() => {
      shots = [];
      turn = 1 - turn;
      turnTransitioning = false;
      beginTurn();
      toast(reason);
    }, 550);
  }

  // ===== Input: drag to shoot =====
  let dragging = false;
  let dragStart = null;
  let dragNow = null;

  function getMousePos(e){
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
  }

  function spawnPosFor(pl) {
    // ì† ê·¼ì²˜
    const dir = (pl.id === 'seo') ? 1 : -1;
    return { x: pl.x + dir * (pl.body.w * 0.62), y: pl.y - pl.body.h * 0.72 };
  }

  function canGrabAmmo(m, ownerIndex) {
    const pl = players[ownerIndex];
    const sp = spawnPosFor(pl);
    const r = pl.projectile.r + 20;
    return Math.hypot(m.x - sp.x, m.y - sp.y) <= r;
  }

  canvas.addEventListener('mousedown', (e) => {
    if (!running) return;
    if (turnTransitioning) return;
    if (shotInAir) return; // íƒ„ ë¹„í–‰ ì¤‘ì—” ì…ë ¥ ê¸ˆì§€

    const m = getMousePos(e);
    if (!canGrabAmmo(m, turn)) return;

    dragging = true;
    dragStart = m;
    dragNow = m;
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    dragNow = getMousePos(e);
  });

  window.addEventListener('mouseup', () => {
    if (!dragging) return;
    dragging = false;
    if (!running) return;
    if (turnTransitioning) return;
    if (shotInAir) return;

    const shooter = players[turn];
    const sp = spawnPosFor(shooter);

    const dx = dragNow.x - dragStart.x;
    const dy = dragNow.y - dragStart.y;

    // drag ë°˜ëŒ€ ë°©í–¥ ë°œì‚¬
    let vx = -dx * 6.5;
    let vy = -dy * 6.5;

    // í˜ ì œí•œ
    const speed = Math.min(2200, Math.hypot(vx, vy));
    const angle = Math.atan2(vy, vx);

    const pr = shooter.projectile;
    const finalSpeed = speed * pr.powerMul;
    vx = Math.cos(angle) * finalSpeed;
    vy = Math.sin(angle) * finalSpeed * pr.arcMul;

    // ê¸°ë³¸ ë°©í–¥ ë³´ì • (ì™¼ìª½ì€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ, ì˜¤ë¥¸ìª½ì€ ì™¼ìª½ìœ¼ë¡œ)
    if (shooter.id === 'seo' && vx < 0) vx *= 0.65;
    if (shooter.id === 'jokbal' && vx > 0) vx *= 0.65;

    shots.push(new Shot(turn, sp.x, sp.y, vx, vy));
    shotInAir = true; // ì´ì œ íƒ„ì´ ë‚ ì•„ê°„ë‹¤(ì…ë ¥ ì ê¸ˆ)
  });

  // ===== Buttons =====
  startBtn.onclick = () => {
    reset();
    running = true;
    toast("ê²Œì„ ì‹œì‘! ì£¼ë°© í¬íŠ¸ë¦¬ìŠ¤ ON");
    beginTurn();
  };
  resetBtn.onclick = () => reset();

  function reset(){
    running = false;
    shots = [];
    players[0].hp = 100;
    players[1].hp = 100;
    players[0].x = 160;
    players[1].x = 740;
    turn = 0;
    wind = 0;
    windEl.textContent = "0";
    setTurnUI();
    timerEl.textContent = "--";
    shotInAir = false;
    turnTransitioning = false;
    dragging = false;
    toast("ë¦¬ì…‹ ì™„ë£Œ. ê²Œì„ ì‹œì‘ì„ ëˆŒëŸ¬!");
  }

  function toast(t){ msgEl.textContent = "ğŸ’¬ " + t; }

  // ===== Drawing: Kitchen background =====
  function drawKitchen() {
    // wall base
    ctx.fillStyle = "rgba(255,255,255,0.03)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // ceiling light
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.beginPath();
    ctx.ellipse(canvas.width/2, 55, 165, 55, 0, 0, Math.PI*2);
    ctx.fill();

    // upper cabinets
    ctx.fillStyle = "rgba(255,255,255,0.07)";
    ctx.fillRect(520, 105, 340, 80);
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.strokeRect(520, 105, 340, 80);
    ctx.beginPath();
    ctx.moveTo(690,105); ctx.lineTo(690,185); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(780,105); ctx.lineTo(780,185); ctx.stroke();

    // fridge left
    ctx.fillStyle = "rgba(255,255,255,0.09)";
    ctx.fillRect(70, 120, 130, 255);
    ctx.fillStyle = "rgba(255,255,255,0.12)";
    ctx.fillRect(70, 120, 130, 44);
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fillRect(188, 186, 6, 78);
    ctx.fillRect(188, 280, 6, 70);

    // sink/counter
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.fillRect(520, 290, 350, 105);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(520, 276, 350, 16);

    // sink bowl
    ctx.fillStyle = "rgba(2,6,23,0.35)";
    ctx.fillRect(600, 312, 130, 60);
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.strokeRect(600, 312, 130, 60);

    // small utensils on counter (dots)
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    for (let i=0;i<9;i++){
      ctx.beginPath();
      ctx.arc(760 + i*10, 310 + (i%3)*8, 2.2, 0, Math.PI*2);
      ctx.fill();
    }

    // floor tiles
    ctx.fillStyle = "rgba(255,255,255,0.05)";
    ctx.fillRect(LEFT, GROUND_Y, canvas.width - LEFT*2, 70);
    ctx.strokeStyle = "rgba(255,255,255,0.05)";
    ctx.lineWidth = 1;
    for (let x=LEFT; x<RIGHT; x+=40){
      ctx.beginPath();
      ctx.moveTo(x, GROUND_Y);
      ctx.lineTo(x, GROUND_Y+70);
      ctx.stroke();
    }

    // label
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.font = "14px system-ui";
    ctx.fillText("ì£¼ë°© ê²°íˆ¬ì¥", 42, 92);

    // actual ground line
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(LEFT, GROUND_Y, canvas.width - LEFT*2, 8);
  }

  function drawHPBar(pl, x, y) {
    const w = 260, h = 14;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = "rgba(239,68,68,0.8)";
    ctx.fillRect(x, y, w * (pl.hp/100), h);
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(x, y, w, h);
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = "13px system-ui";
    ctx.fillText(`${pl.name} HP ${pl.hp}`, x, y - 6);
  }

  function drawWindGauge() {
    // mid-top wind line
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.font = "14px system-ui";
    ctx.fillText("ë°”ëŒ", canvas.width/2 - 18, 26);

    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(canvas.width/2 - 90, 40);
    ctx.lineTo(canvas.width/2 + 90, 40);
    ctx.stroke();

    // wind marker
    const wNorm = Math.max(-1, Math.min(1, wind / BASE_WIND));
    ctx.strokeStyle = "rgba(59,130,246,0.55)";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(canvas.width/2, 40);
    ctx.lineTo(canvas.width/2 + wNorm * 90, 40);
    ctx.stroke();
  }

  // ìºë¦­í„°ë¥¼ ì‚¬ì§„ â€œë³µì œâ€ê°€ ì•„ë‹ˆë¼ â€œíŠ¹ì§•ë§Œ ì‚´ë¦° ë§Œí™” ì‹¤ë£¨ì—£â€ìœ¼ë¡œ í‘œí˜„
  function drawPlayer(pl) {
    const x = pl.x;
    const y = pl.y;

    ctx.save();
    ctx.translate(x, y);

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.ellipse(0, 6, pl.body.w*0.55, 10, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.ellipse(0, -pl.body.h/2, pl.body.w/2, pl.body.h/2, 0, 0, Math.PI*2);
    ctx.fill();

    // head
    const headY = -pl.body.h - pl.head.r + 10;
    ctx.beginPath();
    ctx.arc(0, headY, pl.head.r, 0, Math.PI*2);
    ctx.fill();

    // face
    ctx.fillStyle = "rgba(2,6,23,0.55)";
    if (pl.id === 'seo') {
      // ë¬´í‘œì • ëˆˆ + ì…
      ctx.beginPath(); ctx.arc(-6, headY-2, 2.2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc( 6, headY-2, 2.2, 0, Math.PI*2); ctx.fill();
      ctx.fillRect(-8, headY+8, 16, 2);

      // "ê³¨ë ˜" ëŒë¬´ëŠ¬
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      for (let i=0;i<7;i++){
        ctx.fillRect(-pl.body.w/2 + 6 + i*10, -pl.body.h + 18 + (i%2)*16, 8, 10);
      }
    } else {
      // ëŒ€ë¨¸ë¦¬ í•˜ì´ë¼ì´íŠ¸
      ctx.fillStyle = "rgba(255,255,255,0.12)";
      ctx.beginPath();
      ctx.arc(0, headY-6, 7, 0, Math.PI*2);
      ctx.fill();

      // ì•ˆê²½(ëŠë‚Œ)
      ctx.strokeStyle = "rgba(2,6,23,0.35)";
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(-8, headY, 9, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc( 8, headY, 9, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(- -1, headY); ctx.lineTo(1, headY);
      ctx.stroke();

      // ëˆˆ/ì…(ì°¡ê·¸ë¦¼)
      ctx.fillStyle = "rgba(2,6,23,0.55)";
      ctx.beginPath(); ctx.arc(-7, headY+1, 2.4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc( 7, headY+1, 2.4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath();
      ctx.arc(0, headY+12, 7, 0.15*Math.PI, 0.85*Math.PI);
      ctx.strokeStyle = "rgba(2,6,23,0.55)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // arm
    const dir = (pl.id === 'seo') ? 1 : -1;
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fillRect(dir*(pl.body.w/2 - 4), -pl.body.h*0.78, dir*44, 10);

    // name
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.font = "14px system-ui";
    ctx.fillText(pl.name, -26, 32);

    ctx.restore();
  }

  function drawAmmoReady() {
    if (!running) return;
    if (shotInAir) return; // íƒ„ ë¹„í–‰ ì¤‘ì´ë©´ ìƒˆ íƒ„ í‘œì‹œ X

    const pl = players[turn];
    const sp = spawnPosFor(pl);

    ctx.save();
    ctx.translate(sp.x, sp.y);

    if (pl.projectile.kind === 'jokbal') {
      ctx.beginPath();
      ctx.arc(0,0,pl.projectile.r,0,Math.PI*2);
      ctx.fillStyle="rgba(236,179,95,0.95)"; ctx.fill();
      ctx.strokeStyle="rgba(255,255,255,0.9)";
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(-6,-2); ctx.lineTo(10,7); ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.arc(0,0,pl.projectile.r,0,Math.PI*2);
      ctx.fillStyle="rgba(147,197,253,0.95)"; ctx.fill();
      ctx.fillStyle="rgba(2,6,23,0.75)";
      ctx.beginPath(); ctx.arc(4,-3,2.2,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle="rgba(2,6,23,0.35)";
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(-pl.projectile.r,0); ctx.lineTo(-pl.projectile.r-8,-6);
      ctx.moveTo(-pl.projectile.r,0); ctx.lineTo(-pl.projectile.r-8, 6);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawDragLine() {
    if (!dragging) return;

    const pl = players[turn];
    const sp = spawnPosFor(pl);

    ctx.strokeStyle = "rgba(59,130,246,0.65)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(sp.x, sp.y);
    ctx.lineTo(dragNow.x, dragNow.y);
    ctx.stroke();

    const dx = dragNow.x - dragStart.x;
    const dy = dragNow.y - dragStart.y;
    const strength = Math.min(100, Math.hypot(dx,dy));
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = "16px system-ui";
    ctx.fillText("í˜: " + Math.round(strength), sp.x - 10, sp.y - 22);
  }

  // ===== Main loop =====
  function loop(now) {
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    // turn timer
    if (running) {
      turnTimeLeft -= dt;
      timerEl.textContent = turnTimeLeft.toFixed(0) + "s";

      // ì‹œê°„ì´ ëë‚¬ëŠ”ë° ì•„ì§ ë°œì‚¬ ì•ˆ í–ˆìœ¼ë©´ í„´ ë„˜ê¹€
      if (turnTimeLeft <= 0 && !shotInAir && !turnTransitioning) {
        endTurn("ì‹œê°„ ì´ˆê³¼! í„´ ë„˜ì–´ê°");
      }
    }

    // update shots
    for (const s of shots) s.update(dt);
    shots = shots.filter(s => !s.dead);

    // íƒ„ì´ ì™„ì „íˆ ì—†ì–´ì¡Œê³ , ë°œì‚¬í–ˆë˜ ìƒíƒœë¼ë©´ (ë¯¸ìŠ¤ ì²˜ë¦¬ endTurnì´ ì´ë¯¸ í–ˆê² ì§€ë§Œ ì•ˆì „ì¥ì¹˜)
    if (running && shotInAir && shots.length === 0 && !turnTransitioning) {
      // ì—¬ê¸°ì„œëŠ” ê·¸ëƒ¥ ì…ë ¥ë§Œ í’€ì–´ì£¼ì§€ ì•Šê³  endTurnì´ ì²˜ë¦¬í•˜ë„ë¡ ë‘ëŠ” ê²Œ ì•ˆì •ì .
      // endTurnì´ ì•ˆ ë¶ˆë¦° ì˜ˆì™¸ë¥¼ ëŒ€ë¹„í•´ ì•„ì£¼ ì§§ì€ ì§€ì—° í›„ ì²˜ë¦¬:
      setTimeout(() => {
        if (running && shotInAir && shots.length === 0 && !turnTransitioning) {
          endTurn(`${players[turn].name} ê³µê²© ë¹—ë‚˜ê°â€¦`);
        }
      }, 10);
    }

    // render
    ctx.clearRect(0,0,canvas.width,canvas.height);

    drawKitchen();
    drawHPBar(players[0], 40, 18);
    drawHPBar(players[1], canvas.width - 300, 18);
    drawWindGauge();

    drawPlayer(players[0]);
    drawPlayer(players[1]);

    drawAmmoReady();
    drawDragLine();

    for (const s of shots) s.draw();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // init
  reset();

})();
</script>
</body>
</html>
